var esprima;
var escodegen;
var _;

module.exports = function exports(code, file, catchbody) {
  var astbody; var catcher; var root;
  var fns; var result;
  esprima = esprima || require('esprima-fb');
  escodegen = escodegen || require('escodegen-wallaby');
  _ = _ || require('lodash');

  _.templateSettings = {
    evaluate: /\{\{#([\s\S]+?)\}\}/g, // {{# console.log("blah") }}
    interpolate: /\{\{[^#\{]([\s\S]+?)[^\}]\}\}/g, // {{ title }}
    escape: /\{\{\{([\s\S]+?)\}\}\}/g, // {{{ title }}}
  };

  if (catchbody) {
    astbody = JSON.stringify(esprima.parse(catchbody).body);
    catcher = function (fnIId) {
      return JSON.parse(astbody.replace('{{fnIId}}', fnIId));
    };
  } else {
    catcher = function () {
      return [];
    };
  }

  root = esprima.parse(code, {
    sourceType: 'module',
    loc: true
  });

  fns = [];

  function isFn(el) {
    return el instanceof Object && !(el instanceof Array) &&
      (el.type === 'FunctionDeclaration' || el.type === 'FunctionExpression' || el.type === 'ArrowFunctionExpression');
  }

  function parse(rootContent) {
    _.each(rootContent, function (el) {
      if (isFn(el)) fns.push(el);
      if (el instanceof Object) parse(el);
    });
  }

  parse(root);

  _.each(fns, function each(fn, index) {
    // move nested functions outside the body
    var item = fn;
    var nestedFns = [];
    var errorPosition = esprima.parse('e.position = "' + file + ' ' + item.loc.start.line + ':' + item.loc.end.line + '"');

    _.each(item.body.body, function (el) {
      if (isFn(el)) {
        nestedFns.push(el);
        item.body.body = _.without(item.body.body, el);
      }
    });

    item.body.body = nestedFns.concat([{
      type: 'TryStatement',
      block: {
        type: 'BlockStatement',
        body: item.body.body
      },
      guardedHandlers: [],
      handlers: [{
        type: 'CatchClause',
        param: {
          type: 'Identifier',
          name: 'e'
        },
        body: {
          type: 'BlockStatement',
          body: errorPosition.body.concat(catcher(index))
        }
      }],
      finalizer: null
    }]);
  });

  result = escodegen.generate(root, {
    format: {
      preserveBlankLines: true
    }
  });

  return result;
};
