#!/usr/bin/env node

/**
 * 指定项目远程执行 Jenkins 构建
 * 命令可以传递两个参数
 *  i. 第一个参数为需要构建的路径
 *  ii. 第二个参数为构建的项目名称（可选，默认为当前执行命令的根目录项目名称）
 * 例如：在 package.json 中定义 script 脚本
 *  "jenkins": "./jenkins.build.js image-gallery/dist fp"
 *  终端执行：npm run jenkins
 * Jenkins 构建需要远程登录，所以在用户本地需要只定 token 文件提供本命令读取，
 *  用户 token 由 Jenkins 平台生成，
 *  由 localUserTokenPath 字段定义，默认读取用户 home 目录下的 user_token 文件
 */

var http = require('http');
var querystring = require('querystring');
var zlib = require('zlib');
var fs = require('fs');
var path = require('path');
var os = require('os');
var readline = require('readline');
var util = require('util');

var debuglog = util.debuglog('log');
var argv = process.argv.splice(2);

/**
 * 用户本地 token 文件路径
 */
var localUserTokenPath = path.join(os.homedir(), '/user_token');
/**
 * 读取用户配置信息缓存在这里，提供后续调用
 * 配置会按行读取并存储在数组的每一项
 */
var rsa = [];
/**
 * 项目名称
 */
var projectName;
/** 构建自定义路径 */
var buildPath;
/** 上传到ftp的包名称 */
var pName;
/** 98 www下同步子目录路径 */
var remotePath;
/**
 * 请求 consoleText 超时时间（秒）
 */
var timeout = 30;
var time = 0;

/**
 * 获得当前项目名称
 */
var getProjectName = function getProjectName() {
  var cwd = process.cwd();
  var index = cwd.lastIndexOf(path.sep);
  return cwd.substring(index + 1);
};
/**
 * 获得用户 token 用来远程登录
 * @param {Function} callback 读取用户 token 信息后执行函数，
 * 传递用户 token 继续执行下一步构建流程
 */
var getUserToken = function getUserToken(callback) {
  var rl = readline.createInterface({
    input: fs.createReadStream(localUserTokenPath, 'utf-8')
  });
  rl.on('line', function (line) {
    rsa.push(line);
  }).on('close', function () {
    if (!rsa.length) {
      throw new Error('无法读取用户 token 配置');
    }
    callback(rsa[0]);
  });
};
/**
 * 根据 URL 地址发送 get 请求，完成后执行 callback 回调函数
 * @param {String} url http get 请求地址
 * @param {Function} callback 请求完成后执行回调函数并传递请求数据
 */
var httpGet = function httpGet(url, callback) {
  var request = http.request({
    hostname: 'ci.chinaso365.com',
    path: url,
    method: 'GET',
    headers: {
      'Content-Type': 'application/json; charset=UTF-8',
    }
  }, function (response) {
    var headers = response.headers;
    var endoding = headers['content-encoding'];
    var gunzip; var buffer = [];
    debuglog('headers', headers);
    debuglog('statusCode', response.statusCode);
    // 判断是否返回的 response 存在 gzip 压缩，存在则先解压
    if (endoding && endoding.toLowerCase().indexOf('gzip') > -1) {
      console.log('unzip...');
      gunzip = zlib.createGunzip();
      response.pipe(gunzip);
      gunzip.on('data', function (data) {
        buffer.push(data.toString());
      }).on('end', function () {
        // console.log('cconsole: ', buffer.join(''));
        callback(buffer.join(''), response.statusCode);
      });
    } else {
      response.setEncoding('utf-8');
      response.on('data', function (chunk) {
        buffer.push(chunk.toString());
      });
      response.on('end', function () {
        // console.log('cconsole: ', buffer.join(''));
        callback(buffer.join(''), response.statusCode);
      });
    }
  });
  console.log('请求地址：', url);

  request.on('error', function (e) {
    console.log('error: ', e);
  });

  request.end();
};
/**
 * 根据项目名称和项目构建 ID 获得构架打印信息
 * @param {String} pn 构建的项目名称
 * @param {Number} number 项目构建的 ID
 */
var getBuildConsoleText = function getBuildConsoleText(pn, number) {
  var url = '/view/f_fe/job/' + pn + '/' + number + '/consoleText';
  httpGet(url, function (text) {
    console.log('cconsole: ', text);
  });
};
/**
 * 根据构建项目名称和项目构建 ID 来判断项目是否构建、是否构建完成
 * 完成后加载构建完成打印信息
 * @param {String} pn 构建项目名称
 * @param {Number} number 项目构建 ID
 */
var isBuildDone = function isBuildDone(pn, number) {
  var url = '/view/f_fe/job/' + pn + '/' + number + '/api/json';
  httpGet(url, function (data, status) {
    var json;
    // 判断请求是否超时
    // 因为存在递归调用，所以有必要限定超时条件
    if (time > timeout) {
      throw new Error('请求 console text 超时');
    }
    time += 1;
    // 判断请求的返回状态是否为 200 成功
    // 没有成功状态则代表请求需要重新加载
    // 等待 Jenkins 完成相关操作后接口状态将返回 200
    if (+status !== 200) {
      setTimeout(function () {
        isBuildDone(pn, number);
      }, 1000);
      return false;
    }
    json = JSON.parse(data);
    // 判断 Jenkins 是否完成构建
    // 没有完成构建时则等待
    // 完成后获取 console text 信息
    if (json.building) {
      setTimeout(function () {
        isBuildDone(pn, number);
      }, 1000);
      return false;
    }
    return getBuildConsoleText(pn, number);
  });
};
var getLastBuildNumber = function getLastBuildNumber(json) {
  return json.lastBuild.number;
};
var isInQueue = function isInQueue(json) {
  return json.inQueue;
};
var getNextBuildNumber = function getNextBuildNumber(json) {
  return json.nextBuildNumber;
};
/**
 * 获得当前构建的项目状态
 * @param {String} pn 当前构建的项目名称
 */
var getJobBuild = function getJobBuild(pn) {
  var url = '/view/f_fe/job/' + pn + '/api/json';
  httpGet(url, function (data) {
    var json = JSON.parse(data);
    var inQueue = isInQueue(json);
    var jobNumber = getLastBuildNumber(json);
    if (inQueue) {
      jobNumber = getNextBuildNumber(json);
    }
    isBuildDone(pn, jobNumber);
  });
};
/**
 * POST 构建
 * @param {String} ut 远程登录需要用户权限
 * @param {String} pn 项目名称
 * @param {String} SPECIFC_RSYNC_PATH 构建自定义路径
 * @param {String} FE_PRJ_NAME
 * @param {String} REMOTE_RSYNC_PATH 98 www下同步子目录路径
 */
var build = function build(ut, pn, SPECIFC_RSYNC_PATH, FE_PRJ_NAME, REMOTE_RSYNC_PATH) {
  // Jenkins POST 构建提供数据对象
  var postData = querystring.stringify({
    json: '{"parameter": [' +
      '{"name": "SPECIFC_RSYNC_PATH", "value": "' + SPECIFC_RSYNC_PATH + '"},' +
      '{"name": "FE_PRJ_NAME", "value": "' + FE_PRJ_NAME + '"},' +
      '{"name": "REMOTE_RSYNC_PATH", "value": "' + REMOTE_RSYNC_PATH + '"}' +
    ']}'
  });
  var request = http.request({
    hostname: 'ci.chinaso365.com',
    path: '/view/f_fe/job/' + pn + '/build',
    method: 'POST',
    auth: ut,
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
      'Content-Length': Buffer.byteLength(postData)
    }
  }, function (response) {
    var headers = response.headers;
    var endoding = headers['content-encoding'];
    var gunzip; var buffer = [];
    debuglog('headers', headers);
    debuglog('statusCode', response.statusCode);
    if (endoding && endoding.toLowerCase().indexOf('gzip') > -1) {
      gunzip = zlib.createGunzip();
      response.pipe(gunzip);
      gunzip.on('data', function (data) {
        buffer.push(data.toString());
      }).on('end', function () {
        // console.log('buffer: ', buffer.join(''));
        if (buffer.length) {
          throw new Error(buffer.join(''));
        }
        getJobBuild(pn);
      });
    } else {
      response.setEncoding('utf-8');
      response.on('data', function (chunk) {
        buffer.push(chunk.toString());
      });
      response.on('end', function () {
        // console.log('buffer: ', buffer.join(''));
        if (buffer.length) {
          throw new Error(buffer.join(''));
        }
        getJobBuild(pn);
      });
    }
  });

  request.on('error', function (e) {
    console.log('error: ', e);
  });

  request.write(postData);
  request.end();
};

if (!argv.length) {
  throw new Error('必须的参数“构建路径”没有指定。');
}

buildPath = argv[0];
projectName = argv[1] || getProjectName();
pName = argv[2] || projectName;
remotePath = argv[3] || projectName + 'html';
debuglog('buildPath', buildPath);
debuglog('projectName', projectName);
debuglog('pName', pName);
debuglog('remotePath', remotePath);
getUserToken(function (token) {
  // 执行构建
  build(token, projectName, buildPath, pName, remotePath);
});
